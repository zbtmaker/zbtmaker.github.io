<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="滑动窗口专题往往题目的描述都是，给定一个固定的长度，然后在目标数组和字符串中寻找满足固定长度的字数组或者是子字符串。这类题目，通常采用双指针构造固定长度的滑动窗口，但是有时也需要借助其他的一些数据结构满足这类题目。 滑动窗口总体的步骤：  构造滑动窗口，通过题目给定的固定长度，采用双指针left和right指针来维护一个固定大小的窗口。 存储窗口内数据，采用HashMap、大顶堆或者小顶堆、优先队">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode专题-滑动窗口">
<meta property="og:url" content="http://example.com/2021/03/20/LeetCode%E4%B8%93%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/index.html">
<meta property="og:site_name" content="zbtmaker">
<meta property="og:description" content="滑动窗口专题往往题目的描述都是，给定一个固定的长度，然后在目标数组和字符串中寻找满足固定长度的字数组或者是子字符串。这类题目，通常采用双指针构造固定长度的滑动窗口，但是有时也需要借助其他的一些数据结构满足这类题目。 滑动窗口总体的步骤：  构造滑动窗口，通过题目给定的固定长度，采用双指针left和right指针来维护一个固定大小的窗口。 存储窗口内数据，采用HashMap、大顶堆或者小顶堆、优先队">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-20T04:08:17.062Z">
<meta property="article:modified_time" content="2021-05-09T05:14:33.952Z">
<meta property="article:author" content="邹柏涛">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Sliding Window">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/03/20/LeetCode%E4%B8%93%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeetCode专题-滑动窗口 | zbtmaker</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zbtmaker</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">千里之行, 始于足下</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/LeetCode%E4%B8%93%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="邹柏涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zbtmaker">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode专题-滑动窗口
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 12:08:17" itemprop="dateCreated datePublished" datetime="2021-03-20T12:08:17+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-09 13:14:33" itemprop="dateModified" datetime="2021-05-09T13:14:33+08:00">2021-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>滑动窗口专题往往题目的描述都是，给定一个固定的长度，然后在目标数组和字符串中寻找满足固定长度的字数组或者是子字符串。这类题目，通常采用双指针构造固定长度的滑动窗口，但是有时也需要借助其他的一些数据结构满足这类题目。</p>
<p>滑动窗口总体的步骤：</p>
<ul>
<li>构造滑动窗口，通过题目给定的固定长度，采用双指针left和right指针来维护一个固定大小的窗口。</li>
<li>存储窗口内数据，采用HashMap、大顶堆或者小顶堆、优先队列、单调队列等各种数据结构存储窗口内数据</li>
<li>滑动窗口，如果碰到不满足条件的数据有两种操作，一种是重置窗口起始位置（将左右指针移动到当前数据下一个位置），另一种是移动窗口的<strong>左指针</strong>，直到窗口内的数据满足条件为止。</li>
</ul>
<a id="more"></a>

<h4 id="LC76-最小覆盖子串"><a href="#LC76-最小覆盖子串" class="headerlink" title="LC76 最小覆盖子串"></a>LC76 最小覆盖子串</h4><p><strong>题目描述</strong></p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<strong>注意</strong>：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p><strong>测试用例</strong></p>
<p>Case1:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure>
<p>Case2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<p>这个题目适合使用滑动窗口思想来实现，窗口的大小为包含了字符串 $t$ 的长度。同样我们使用两个指针 $left$ 、$right$ 来实现。我们第一步应该是用$HashMap$来统计字符 $t$ 中每个字符出现的频次，同时需要用一个变量 $min =Integer.MAX_VALUE$ 表示最小覆盖字符串长度，如果最终最小覆盖长度为$Integer.MAX_VALUE$，那么表示代码中不存在覆盖子串，此时返回<strong>空字符串</strong>。我们用一个变量 $tLen$表示当前还剩下多少未覆盖的字符串长度，最初 $tLen = t.length()$。</p>
<p>接下来分析左右指针向左右移动时的操作，$right$ 指针不断向右移动，如果碰到下面的情况</p>
<ul>
<li>如果$HashMap$ 中的某个字符的频次已经小于0了，此时 $tLen$ 不应该再减少了，同时 $right$ 指针可以依次向右移动。</li>
<li>如果 $tLen = 0$，此时表明，区间 $[left,right]$已经能够覆盖字符串 $t$ 了，那么此时应该应该将 $left$指针向右移动，每一次移动 $left$指针都需要判断 $tLen = 0$是否成立，如果成立，然后和 $min$ 作比较，记录最小覆盖子串。</li>
<li>这里在移动 $left$指针的时候需要考虑清楚的是什么时候停止移动，应该是移动到 $tLen \neq 0$停止移动。在移动指针的时候需要根据字符是否是存在于 $HashMap$ 来判断是否增加$tLen$的值。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinWindow76</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、暴力破解方式，时间复杂度为O(N^2),空间复杂度O(N)</span></span><br><span class="line"><span class="comment">     * 2、滑动窗口方式，时间复杂度为O(N),空间复杂度为O(N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 匹配字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 目标字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最小覆盖子串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charMapCount = charCount(t);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sLen = s.length(), tLen = t.length(), start = -<span class="number">1</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; sLen) &#123;</span><br><span class="line">            <span class="keyword">char</span> rightCh = s.charAt(right);</span><br><span class="line">            Integer rightChCount = charMapCount.get(rightCh);</span><br><span class="line">            <span class="keyword">if</span> (rightChCount != <span class="keyword">null</span>) &#123;</span><br><span class="line">                --rightChCount;</span><br><span class="line">                <span class="keyword">if</span> (rightChCount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    tLen--;</span><br><span class="line">                &#125;</span><br><span class="line">                charMapCount.put(rightCh, rightChCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (tLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    min = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> leftCh = s.charAt(left);</span><br><span class="line">                Integer leftChCount = charMapCount.get(leftCh);</span><br><span class="line">                <span class="keyword">if</span> (leftChCount != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ++leftChCount;</span><br><span class="line">                    <span class="keyword">if</span> (leftChCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ++tLen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    charMapCount.put(leftCh, leftChCount);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Character, Integer&gt; <span class="title">charCount</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charMapCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            charMapCount.put(ch, charMapCount.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> charMapCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LC438-找到字符串中所有字母异位词"><a href="#LC438-找到字符串中所有字母异位词" class="headerlink" title="LC438.找到字符串中所有字母异位词"></a>LC438.找到字符串中所有字母异位词</h4><p><strong>题目描述</strong>：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p><strong>分析</strong>：这个题目最先想到的就是使用滑动窗口，需要在字符串 $s$ 中找到所有的子串为字符串 $p$ 的排列，因此窗口的大小为字符串 $p$ 的长度，我们这里计为$pLen$。</p>
<p>我们用两个指针确定窗口大小，分别为左指针 $left$、右指针 $right$。现在需要做的就是确定什么时候应该移动左右指针，右指针每次都是移动一次，我们把$s.charAt(right)$ 计为 $ch$。对于 $ch$需要做如下讨论：</p>
<ul>
<li>如果字符串 $p$ 包含字符 $ch$ ，那么需要判断在$left$ 和 $right$ 指针之间的 $ch$ 出现的次数超出了字符串 $p$ 中出现的频次，<ul>
<li>如果字符 $ch$ 在$[left,right]$ 出现的频次未超出了字符串 $p$，则右指针 $right$ 继续向右移动，而左指针保持不动。</li>
<li>如果字符 $ch$ 在$[left,right]$ 出现的频次超出了字符串 $p$，那么此时 $left$指针向左移动，直到刚好满足条件。</li>
</ul>
</li>
<li>如果字符串 $p$ 不包含字符 $ch$，那么表示这个子串应该从下一个位置开始，则 $right = right + 1$， $left = right + 1$。</li>
<li>最后一种情况就是，如果$[left,right]$ 区间的字字符串刚好是字符串$p$ ，那么此时右指针 $right$继续往右走就好了，这个时候往右移动，区间$[left,right]$ 必然不会满足字符串的条件，此时就超出频次，左指针 $left$ 往右移动就好了。</li>
</ul>
<p>这里还需要注意的就是：当 $[left,right]$ 区间包含的字符串不满足条件时，此时需要恢复现场，我们用 $HashMap$ 存储字符串$p$ 中每个字符出现的次数，$right$ 指针每移动一次，则 $HashMap$ 就对相应的字符出现次数扣减一次，如果$[left,right]$ 区间出现不满足条件的字符或者字符出现的频次超出了 $HashMap$ 统计范围此时就需要移动 $left$ 指针，然后将之前扣减的字符频次依次找补回来。</p>
<p>因此我们具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindAnagrams438</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口，时间复杂度O(N), 空间复杂度O(N)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 目标字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子串位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charMapCount = charCount(p);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, pLen = p.length();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(right);</span><br><span class="line">            <span class="comment">//如果[left,right]中出现了p中不存在的字符串，左指针向右移动，在移动的同时</span></span><br><span class="line">            <span class="comment">//需要将之前扣减的字符统计恢复成原来的样子</span></span><br><span class="line">            <span class="keyword">if</span> (!charMapCount.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmpCh = s.charAt(left);</span><br><span class="line">                    charMapCount.put(tmpCh, charMapCount.get(tmpCh) + <span class="number">1</span>);</span><br><span class="line">                    pLen++;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> count = charMapCount.get(ch);</span><br><span class="line">                count--;</span><br><span class="line">                pLen--;</span><br><span class="line">                <span class="comment">//如果[left,right]之间出现的字符频率超出了字符串p中出现的频次，同样需要将</span></span><br><span class="line">                <span class="comment">//将之前扣减出来的数据恢复现场</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmpCh = s.charAt(left);</span><br><span class="line">                    <span class="keyword">if</span> (tmpCh == ch) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    charMapCount.put(tmpCh, charMapCount.get(tmpCh) + <span class="number">1</span>);</span><br><span class="line">                    pLen++;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                charMapCount.put(ch, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果[left,right]对应的子串刚好是字符串p的一个排列</span></span><br><span class="line">            <span class="keyword">if</span> (pLen == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Character, Integer&gt; <span class="title">charCount</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = p.charAt(i);</span><br><span class="line">            map.put(ch, map.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LC567-字符串的排列"><a href="#LC567-字符串的排列" class="headerlink" title="LC567. 字符串的排列"></a>LC567. 字符串的排列</h4><p>这个题目描述：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列</a></p>
<p>这个题目要在一个字符串$s_2$中找到一个子串（连续的字符串），这个子串是$s_1$的一个排列，那么我们就需要在$s_2$中维持一个长度等于$s_1$字符串长度的窗口大小。因为字符串中只包含小写字字母，所以采用固定长度为26的数组会很方便。</p>
<ul>
<li>采用$count$数组记录$ S_1$字符串每一个字符出现的频次，$flag$ 数组记录字符$a$～$z$ 是否在字符串$S_1$出现。</li>
<li>遍历字符串$S_2$，如果$S_2$中的字符不是$S_1$中的字符，此时需要重新两个指针需要重新计算，此时需要重置$count$数组。</li>
<li>如果出现$S_2$中字符数超出了$S_1$的字符数，则需要将滑动窗口缩小，直到窗口能够满足我们的条件为止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckInclusion567</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化窗口数据</span></span><br><span class="line">        <span class="keyword">int</span>[] flag = initFlagArr(s1), count = initCountArr(s1);</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="comment">//遍历目标数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s2.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//完全不满足窗口条件，则初始化窗口数据</span></span><br><span class="line">            <span class="keyword">if</span> (flag[ch] == <span class="number">0</span>) &#123;</span><br><span class="line">                count = initCountArr(s1);</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                len = s1.length();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//操作窗口元素</span></span><br><span class="line">                count[ch]--;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="comment">//局部不满足窗口条件则滑动窗口左指针直到满意为止</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt;= i &amp;&amp; count[ch] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmpChar = s2.charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    j++;</span><br><span class="line">                    count[tmpChar]++;</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] initFlagArr(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            flag[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] initCountArr(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LC727-最小窗口子序列"><a href="#LC727-最小窗口子序列" class="headerlink" title="LC727. 最小窗口子序列"></a>LC727. 最小窗口子序列</h4><p><strong>题目描述</strong>：给定字符串 $S$ 、$T$，找出 $S$ 中<strong>最短</strong>的（连续）子串 <em>$W$</em> ，使得 $T$ 是 $W$ 的 子序列 。如果 $S$ 中没有窗口可以包含 $T$ 中的所有字符，返回空字符串 “”。如果有不止一个最短长度的窗口，返回开始位置<strong>最靠左</strong>的那个。</p>
<p><strong>测试用例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;abcdebdde&quot;</span>, T = <span class="string">&quot;bde&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bcde&quot;</span></span><br><span class="line">解释：</span><br><span class="line"><span class="string">&quot;bcde&quot;</span> 是答案，因为它在相同长度的字符串 <span class="string">&quot;bdde&quot;</span> 出现之前。</span><br><span class="line"><span class="string">&quot;deb&quot;</span> 不是一个更短的答案，因为在窗口中必须按顺序出现 T 中的元素。</span><br></pre></td></tr></table></figure>
<p><strong>暴力分析</strong>：这个需要在字符串 $S$ 中找到一个子序列 $W$，使得 $T$ 是 $W$ 的一个子序列。首先我们需要知道什么是子序列，子序列不是连续的，而子串是连续的。这个题目和前面的不同是前面在窗口内可以是无序的，但是这个题目是有序的。</p>
<p> 那我们首先来使用暴力的方式实现，我们对字符串 $S$ 中每一个位置都作为匹配的起始位置 $i$ ，从每一个起始位置开始的子串 $[i,sLen)$ 都和字符串 $T$ 做一次匹配操作。那么每一次至少做$|T|$ 次匹配，那么字符串长度为 $|S|$，就需要做 $|T|<em>|S|$ 次匹配操作，因此暴力解的时间复杂度为 $O(|T|</em>|S|)$ ，空间复杂度为 $O(1)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowSequence727</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minWindowBruteForce(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">minWindowBruteForce</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length(), tLen = t.length();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != t.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; sLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j) == t.charAt(tIndex)) &#123;</span><br><span class="line">                    tIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tIndex == tLen) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min &gt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                        min = j - i + <span class="number">1</span>;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>动态规划</strong>：其实这个题目和最长公共子序列，最长公共子序列用一个辅助二维数组$dp[i][j]$ 记录字符串 $s$ 在范围 $[0,i]$ 和字符串 $T$ 在范围 $[0,j]$范围内的公共子序列长度。递推公式如下：<br>$$<br>dp[i][j]=\left{<br>\begin{aligned}<br>dp[i-1][j -1]+1，s.charAt(i - 1) = t.charAt(j - 1) \<br>max(dp[i-1][j]，dp[i][j-1])+1，s.charAt(i-1) \neq t.charAt(j-1)\<br>\end{aligned}<br>\right.<br>$$<br>那么我们这个题目是否可以用这个方法呢？应该是不行的，如果这个题目只是要判断字符串 $S$ 是否包含一个字符串 $T$ 的子序列，那么用最长公共子序列的思路是可以的，我们只需要判断 $dp[i][j] == |T|$ 是否成立就可以了。但是这个题目要求的是我们在字符串 $S$ 找到一个子序列。</p>
<p>所以我们这里可以借用最长公共子序列的思想，在最长公共子序列扩展一下。用 $tLen$ 表示字符串 $T$ 长度，$sLen$ 表示字符串 $S$ 长度，用辅助二维数组 $dp[i][j]$ 来记录公共子序列的起始位置，其中$0 ≤i≤sLen$，$0≤j ≤tLen$。我们可以看初始值当 $i = 0$，$dp[0][j]=-1$ 表示字符串 $S$ 长度为0，此时自然在字符串 $S$ 中找打一个最小的子字符串 $W$ 使 字符串 $T$ 是其中一个序列。$j = 0$，$dp[i][0] = j$ 表示字符串 $T$ 的长度为0，那么我们在字符串 $S$ 不管长度为什么，都可以找到一个最小的子字符串 $W$ 满足题目要求。</p>
<p>那么我们的递推公式是什么呢？<br>$$<br>dp[i][j]=\left{<br>\begin{aligned}<br>dp[i-1][j -1]，s.charAt(i - 1) = t.charAt(j - 1) \<br>dp[i-1][j]，s.charAt(i-1) \neq t.charAt(j-1)\<br>\end{aligned}<br>\right.<br>$$<br>其实我们可以来看一个例子 S = “abcdebdde”, T = “bde”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	 *		b		d		 e</span><br><span class="line">*  -1   -1  -1   -1</span><br><span class="line">a  1    -1  -1	 -1</span><br><span class="line">b  2		1   -1	 -1</span><br><span class="line">c  3		3 	-1	 -1</span><br><span class="line">d  4		3   3    -1</span><br><span class="line">b  5    4   3    -1</span><br><span class="line">d  6    4   4    -1</span><br><span class="line">d  7    4   4    -1   </span><br><span class="line">e  8    4   4    4</span><br></pre></td></tr></table></figure>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowSequence727</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minWindowByDP(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">minWindowByDP</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length(), tLen = t.length();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sLen + <span class="number">1</span>][tLen + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] aux : dp) &#123;</span><br><span class="line">            Arrays.fill(aux, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tLen; j++) &#123;</span><br><span class="line">                dp[i][j] = s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>) ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][tLen] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; i - dp[i][tLen]) &#123;</span><br><span class="line">                    min = i - dp[i][tLen];</span><br><span class="line">                    start = dp[i][tLen];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
              <a href="/tags/Sliding-Window/" rel="tag"># Sliding Window</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/12/LeetCode%E4%B8%93%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/" rel="prev" title="Leetcode专题-字符串运算">
      <i class="fa fa-chevron-left"></i> Leetcode专题-字符串运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/20/LeetCode%E4%B8%93%E9%A2%98-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" rel="next" title="LeetCode专题-单调队列">
      LeetCode专题-单调队列 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#LC76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">LC76 最小覆盖子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LC438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">2.</span> <span class="nav-text">LC438.找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LC567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">LC567. 字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LC727-%E6%9C%80%E5%B0%8F%E7%AA%97%E5%8F%A3%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">LC727. 最小窗口子序列</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">邹柏涛</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邹柏涛</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
