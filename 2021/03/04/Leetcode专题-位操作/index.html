<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="位运算基本操作移位移位操作分为左移和右移，其中右移操作又分为逻辑右移和算术右移，其中逻辑右移是所有位向右移动一位，最高位补零，而算术右移，则是正整数的算术右移和逻辑右移是一样的，但是负数的逻辑右移是所有位置向右移动一位，然后最高位补1。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode专题-位操作">
<meta property="og:url" content="http://example.com/2021/03/04/LeetCode%E4%B8%93%E9%A2%98-%E4%BD%8D%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="zbtmaker">
<meta property="og:description" content="位运算基本操作移位移位操作分为左移和右移，其中右移操作又分为逻辑右移和算术右移，其中逻辑右移是所有位向右移动一位，最高位补零，而算术右移，则是正整数的算术右移和逻辑右移是一样的，但是负数的逻辑右移是所有位置向右移动一位，然后最高位补1。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-04T15:45:36.780Z">
<meta property="article:modified_time" content="2021-03-14T15:05:07.352Z">
<meta property="article:author" content="zbtmaker">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/03/04/LeetCode%E4%B8%93%E9%A2%98-%E4%BD%8D%E6%93%8D%E4%BD%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeetCode专题-位操作 | zbtmaker</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zbtmaker</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">千里之行, 始于足下</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/LeetCode%E4%B8%93%E9%A2%98-%E4%BD%8D%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zbtmaker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zbtmaker">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode专题-位操作
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-04 23:45:36" itemprop="dateCreated datePublished" datetime="2021-03-04T23:45:36+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 23:05:07" itemprop="dateModified" datetime="2021-03-14T23:05:07+08:00">2021-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="位运算基本操作"><a href="#位运算基本操作" class="headerlink" title="位运算基本操作"></a>位运算基本操作</h2><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>移位操作分为左移和右移，其中右移操作又分为逻辑右移和算术右移，其中逻辑右移是所有位向右移动一位，最高位补零，而算术右移，则是正整数的算术右移和逻辑右移是一样的，但是负数的逻辑右移是所有位置向右移动一位，然后最高位补1。</p>
<a id="more"></a>

<h4 id="逻辑左移"><a href="#逻辑左移" class="headerlink" title="逻辑左移"></a>逻辑左移</h4><p>给定一个数字$x$，用二进制数组表示该数字$[x_{n-1},x_{n-2},…,x_0]$，逻辑左移$k$位后二进制数组$[x_{n- k - 1},x_{n- k- 2},…x_k,0,0,…0]$。逻辑左移操作不需要考虑是正整数和负整数，就是将目前的二进制往左移$k$位，然后低位补0。逻辑左移对应的就是我们算术中乘2操作,逻辑左移的符号是 &lt;&lt;。</p>
<p>1、正整数逻辑左移操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0100 &lt;&lt; <span class="string">1		#移位前4</span></span><br><span class="line"><span class="string">0000 0000 0000 0000 0000 0000 0000 1000				  #移位后8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0100 0000 0000 0000 0000 0000 0000 0100 &lt;&lt; 1</span>    <span class="comment">#移位前1073741828</span></span><br><span class="line">1000 0000 0000 0000 0000 0000 0000 1000 				<span class="comment">#移位后-2^31 + 8 = -2147483640</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、负数的逻辑左移</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0000 &lt;&lt; <span class="string">1		#移位前2^31</span></span><br><span class="line"><span class="string">0000 0000 0000 0000 0000 0000 0000 0000					#移位后0</span></span><br></pre></td></tr></table></figure>
<h4 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移"></a>逻辑右移</h4><p>给定一个数字$x$，用一个二进制数组表示该数字$[x_{n-1},x_{n-2},…x_0]$，逻辑右移$k$位后二进制数组变为了$[0,…x_{n-1},x_{n-2},…,x_k]$，就是将最高位补0即可，不需要区分正负数。</p>
<p>1、正整数逻辑左移操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0100 &gt;&gt; 1		<span class="comment">#移位前4</span></span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010				  <span class="comment">#移位后2</span></span><br></pre></td></tr></table></figure>
<p>2、负数逻辑右移</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0000 &gt;&gt; 1		<span class="comment">#移位前-2^31</span></span><br><span class="line">0100 0000 0000 0000 0000 0000 0000 0000 				<span class="comment">#移位后2^30</span></span><br></pre></td></tr></table></figure>
<h4 id="算术右移"><a href="#算术右移" class="headerlink" title="算术右移"></a>算术右移</h4><p>1、正整数算术右移</p>
<p>2、负数算术右移</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="Leetcode-190"><a href="#Leetcode-190" class="headerlink" title="Leetcode 190"></a>Leetcode 190</h5><p>这个题目和同统计hamming weight不同，这个要把一个数的二进制逆转后的数字输出，那么我们就必须移位31位。所以最终的判断条件应该是移位的次数而不是一个数移位最终位零。我们需要做的就是每次将移出的位添加到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBits190</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">31</span>) &#123;</span><br><span class="line">            sum = (sum &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Leetcode-191"><a href="#Leetcode-191" class="headerlink" title="Leetcode 191"></a>Leetcode 191</h5><p>这个题目就是统计二进制数组中所有1的位数，我们有两种方法，一种是左移，另一种是右移，左移主要是看移动之前的最高位，右移主要是看移动之前的最低位。这里题目的描述是$0 ≤ n ≤ 2^{31}-1$，那么这里用左移或者向右移动都是一样的。那么循环结束的条件都是最终$n$ ==0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1Bits191</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hammingWeightRight(n);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeightRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, b;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            b = n;</span><br><span class="line">            count += (b &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Leetcode-338"><a href="#Leetcode-338" class="headerlink" title="Leetcode 338"></a>Leetcode 338</h5><p>这个题目是给定一个数字$num$，求0 ~ $num$ 所有数字的hamming weight，最开始的想法应该是借助Leet code191的方式，采用for 循环的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountBits338</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            bits[i] = hammingWeight(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeightRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, b;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            b = n;</span><br><span class="line">            count += (b &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式实现的时间复杂度为 $O(32N)\approx O(N)$。空间复杂度都会是$O(N)$。那么有没有简单的方法呢？其实是有的，我们只需要找到列几个数字就能找到相应的规律，下面我们拿1~4举例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000</span><br><span class="line">0001</span><br><span class="line">0010</span><br><span class="line">0011</span><br><span class="line">0100</span><br></pre></td></tr></table></figure>
<p>我们用$bit[i]$表示数字$i$ 的Hamming Weight。从上面可以看出，$bit[3] = bit[2] + 1$，$bit[2] = bit[1]$，$bit[1] = bit[0] + 1$ 。因此我们可以得出部分结论：</p>
<ul>
<li>如果$i$是一个偶数，因为偶数的最低位永远是0，那么下一个奇数其实就是将当前偶数的最低位置1，其他都不用变换，也就是说$bit[i] = bit[i] - 1$，$i&amp;1 \neq 0$。</li>
</ul>
<p>我们找到了奇数和偶数之间的关系，那么偶数的规律怎么找呢，我们从上面的例子可以看出，$4 = 2 * 2$，用移位操作来表示就是$4 = 2&lt;&lt;1$。从上面逻辑左移操作知道，左移移位就是在现有比特数组$[x_{n-1},…x_0]$的基础上左移后$[x_{n-2},x_{n-3},…x_0,0]$，左移可能会把最高位$x_{n-1}$移出去，那么这里会不会影响Hamming Weight呢？其实不会，因为对于正整数，最高位都是0，左移之前Hamming Weight是多少，那么左移之后不变。得出下面的结论</p>
<ul>
<li>$bit[i] = bit[i &gt;&gt; 1]$， $i &amp; 1 = 0$。</li>
</ul>
<p>所以代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountBits338</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于这个题目最初的想法就是计算每一个数字的位1的数量，但是这种方式的时间复杂度为O(N*32)，空间复杂度位O(1)。</span></span><br><span class="line"><span class="comment">     * 这里有个规律，对于一个偶数i，比其比特位数量等于i &gt;&gt; 1的比特位，这是因为4 =2 * 2 = 2 &lt;&lt; 1， 6 = 3 * 2 = 3 &lt;&lt; 1。</span></span><br><span class="line"><span class="comment">     * 所以bit[i] = bit[i &gt;&gt; 1],如何判断一个数是否是偶数，其实就是 i &amp; 1 == 0 表明i就是一个偶数</span></span><br><span class="line"><span class="comment">     * 那么奇数呢？我们知道3 = 2 + 1，就是在偶数的最低位设置位零，而且不会导致进位。通过这种方式，如果i &amp; 1 != 0就表示</span></span><br><span class="line"><span class="comment">     * 我们的i是一个奇数，那么i - 1肯定就是一个偶数，而我们在上面已经得到了偶数的递推关系式了，因此最终的关系如下：</span></span><br><span class="line"><span class="comment">     * i &amp; 1 == 0 ? bit[i] = bit[i &gt;&gt; 1] : bit[i - 1] + 1</span></span><br><span class="line"><span class="comment">     * 我们就能得到</span></span><br><span class="line"><span class="comment">     * bit[i] = bit[i - 1] + 1.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            bits[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? bits[i &gt;&gt; <span class="number">1</span>] : bits[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Leetcode-461"><a href="#Leetcode-461" class="headerlink" title="Leetcode 461"></a>Leetcode 461</h5><p>两个整数之间的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 $x$ 和 $y$，计算它们之间的汉明距离。</p>
<p>分析：要找到两个数字的二进制位置不同的数目，整数$x$的二进制数组$ [x_{n-1},….x0]$，整数$y$的二进制数组$[y_{n-1},…y0]$，二进制不同的位置数目，我们知道比特位操作有与、或、非、同或、异或，对于异或操作，有</p>
<p>$x_{n-1} \ xor\  y_{n-1} = 1$，$x_{n-1} \neq y_{n-1}$</p>
<p>$x_{n-1} \ xor\  y_{n-1} = 0$，$x_{n-1} = y_{n-1}$</p>
<p>因此我们需要先对两个整数做异或操作，然后统计二进制数组的Hamming Weight即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HammingDistance461</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = x ^ y;</span><br><span class="line">        <span class="keyword">return</span> hammingWeightRight(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeightRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, b;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            b = n;</span><br><span class="line">            count += (b &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Leetcode-476"><a href="#Leetcode-476" class="headerlink" title="Leetcode 476"></a>Leetcode 476</h5><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>分析：对于一个正整数，要求其二进制补码的值，而且如果是高位为0，那么就需要停止计算，例如，如果一个数字的二进制数组$[0,..,x_{n-k},x_{n-k-1},…,x_0]$，第$k$ 是1，表示最大有效位。那么我们采用左移的方式来计算正整数的补码，因为方便判断循环结束点。我们还需要一个额外的参数$mask$来记录，当前最低位应该向左移几位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindComplement476</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 正整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 补数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (<span class="number">1</span> ^ (num &amp; <span class="number">1</span>)) &lt;&lt; mask;</span><br><span class="line">            mask++;</span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>异或运算-$\oplus$，从数字逻辑电路知道，异或运算具有一下性质</p>
<p>​                                                               $A \oplus B \oplus C = A \oplus C \oplus B$</p>
<p>​                                                              $A\oplus1 = \overline{A}$</p>
<p>​                                                              $A \oplus 0 = A$</p>
<p>​                                                             $A \oplus A = 0$</p>
<h5 id="Leetcode-136"><a href="#Leetcode-136" class="headerlink" title="Leetcode 136"></a>Leetcode 136</h5><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>分析：因为我们非空数组中，每一个整数都可以用一个32位的比特数组$[x_{n-1},…,x_0]$表示，对两个整数做异或操作相当于对32位的比特位分别执行异或操作。因为对于数组中除了一个元素只出现了一次，而其他元素都出现了两次，我们可以用下面的数学公式来表示</p>
<p> $A \oplus B \oplus C \oplus  B \oplus C = B \oplus B \oplus C \oplus C \oplus A$</p>
<p>因为异或运算支持交换律和结合律，所以最终上面的数学公式最终的结果就是A，数组中只出现一次的元素。</p>
<p>所以代码可以如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber136</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*return singleNumberByHashMap(nums);*/</span></span><br><span class="line">        <span class="keyword">return</span> singleNumberByXOR(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于这种统计重复元素的问题，首先想到的就是使用HashMap来统计重复的元素</span></span><br><span class="line"><span class="comment">     * 出现的次数，然后判断哪个元素的出现的次数只有1。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 目标数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 只出现一次的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">singleNumberByHashMap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = ArrayUtils.count(nums);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用逻辑电路中的异或思想，a^0 = a,a^b^a = a^a^b = 0^b =b</span></span><br><span class="line"><span class="comment">     * 由于题目中明确提示，所有的字符都会出现两次，那么这个时候通过一连串的</span></span><br><span class="line"><span class="comment">     * 异或操作后，由于两个相同元素之间的异或为0，最后剩下的哪个元素肯定就是</span></span><br><span class="line"><span class="comment">     * 我们要找的只出现一次的元素。这种算法使time complexityO(N),space complexity O(1)</span></span><br><span class="line"><span class="comment">     * Beautiful code!</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 目标数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 只出现一次的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">singleNumberByXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Leetcode137"><a href="#Leetcode137" class="headerlink" title="Leetcode137"></a>Leetcode137</h5><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>分析：我们可以用下面的公式来建模这个问题</p>
<p>$A\oplus B \oplus C \oplus D \oplus C \oplus D = A\oplus B$</p>
<p>问题是现在我们得到了数组中所有数字异或的结果，那么如何从数组中将这两个数字分离开来？我们需要将结果$ A \oplus B$分离开来，令$ A \oplus B = Y$ ，则</p>
<p>$[Y_{n-1},…,Y0] = [A_{n-1} \oplus B_{n-1},…,A_0 \oplus B_0]$，由异或运算的结果我们可以知道异或结果得到的都是比特位中不相同的位，那我们在比特数组$[Y_{n-1},…Y_0]$中找到一个$Y_i =1,0 \leq i \leq n-1$。如何快速的找到一个我们用下面的方式可以找到这样的一个位</p>
<p>$X = Y &amp; -Y$</p>
<p>我们来看一个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">&amp;</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1001</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>
<p>那么对于数组中任意一个元素$num$ 和 $X$执行$&amp;$操作，那么就有</p>
<p>我们可以看一个数组</p>
<p>$nums = [1,1,2,2,3,4,5,4]$，所有元素异或操作之后结果就是$Y= 3 \oplus 5$</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0111</span><br><span class="line">^</span><br><span class="line">0011</span><br><span class="line">0100</span><br></pre></td></tr></table></figure>
<p>那么此时我们可以用Y来区分两个数组（虽然这个我也不是很理解），如果$Y &amp; num = 0$，则划分为第一个数组，反之，则划分为另一个数组，因为这两个不同的数组最终包含只有一个只出现一次的 元素，而其他元素都出现了两次，同样另一个数组也是，因此就可以将问题简化为Leet code136了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0001</span><br><span class="line">0001</span><br><span class="line">0010</span><br><span class="line">0010</span><br><span class="line">0011</span><br><span class="line">0100</span><br><span class="line">0111</span><br><span class="line">0100</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            y ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mask = y &amp; (-y);</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mask &amp; num) == <span class="number">0</span>) &#123;</span><br><span class="line">                result[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Latex参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://imzlp.com/posts/23224/">LaTeX 数学符号速查表</a></p>
<p><a target="_blank" rel="noopener" href="https://zinglix.xyz/2017/08/23/latex-maths-cheatsheet/">Latex 数学符号 汇总</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/21/LeetCode%E4%B8%93%E9%A2%98-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="prev" title="Leetcode专题-二分查找">
      <i class="fa fa-chevron-left"></i> Leetcode专题-二分查找
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/12/LeetCode%E4%B8%93%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97/" rel="next" title="Leetcode专题-字符串运算">
      Leetcode专题-字符串运算 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">位运算基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D"><span class="nav-number">1.1.</span> <span class="nav-text">移位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%B7%A6%E7%A7%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">逻辑左移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB"><span class="nav-number">1.1.2.</span> <span class="nav-text">逻辑右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">算术右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.4.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-190"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">Leetcode 190</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-191"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">Leetcode 191</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-338"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">Leetcode 338</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-461"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">Leetcode 461</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-476"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">Leetcode 476</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">逻辑运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-136"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">Leetcode 136</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode137"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Leetcode137</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zbtmaker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zbtmaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
